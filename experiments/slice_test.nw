\documentclass{book}
\usepackage{noweb}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{textcomp}
\usepackage{parskip}
\usepackage{geometry}
\usepackage{xspace}
\usepackage{hyperref}

\def\noweb{{\tt noweb\/}}
\newcommand{\join}{\bowtie}
\newcommand{\MaRI}{\textsf{M4RI}\xspace}

\newcommand{\ZMQ}{\textsf{$\varnothing$MQ}\xspace}
\newcommand{\NN}{\textsf{nanomsg}\xspace}
\newcommand{\MPI}{\textsf{MPI}\xspace}
\newcommand{\OMP}{\textsf{OpenMP}\xspace}

\begin{document}

\setcounter{chapter}{7}
\chapter{Slicer}

This program reads a $C$ hash file and partition it in \emph{slices}. A slice
is a sequence of [[u64]] such that their rank less than (or equal) to a given
threshold, which is approximately $\log_2 [[file size]]$. Then for each slice,
we computes the changes of bases and writes down a matrix file. We use \MaRI
to perform the linear algebra.

Each slice is represented by a [[struct slice_t]]. Slices are concatenated in
a \textbf{slice file}. Each fine task thus requires a single slice file. Slice
files are named [[slice/<key>]].


<<*>>=
#define _XOPEN_SOURCE 500   /* strdup */
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <math.h>

#include <papi.h>

#include "../types.h"

<<Functions>>
<<The main program>>

@ We need the usual standard headers.

<<The main program>>=
int main()
{
	<<Run the test>>
	exit(EXIT_SUCCESS);
}

@ We generate input randomly using RC4.

<<Functions>>=
void RC4_keysetup(u8 *S, u64 key)
{
        for (int i = 0; i < 256; i++)
                S[i] = i;
        // u8 k = key;
        u8 j = 0;
        for (int i = 0; i < 256; i++) {
                j = j + S[i] + key;
                // k = (k * key + 11) % 257;
                u8 x = S[i];
                S[i] = S[j];
                S[j] = x;
        }
}

<<Functions>>=
void RC4_stream(u8 *S, u8 *out, u64 n)
{
        u8 i = 0, j = 0;
        for (u64 k = 0; k < n; k++) {
                i += 1;
                j += S[i];
                u8 x = S[i];
                S[i] = S[j];
                S[j] = x;
                out[k] = S[(S[i] + S[j]) & 0x00ff];
        }
}

<<Functions>>=
double wtime()
{
	return PAPI_get_real_usec() / 1e6;
}


@ We install the input vectors in one of several a linked list: the [[active]]
and [[inactive]] ones. The lists have size $n + 1$ (we include an extra dummy
item at the begining so that they are never empty). At all times, [[n]] counts
the number of non-emited vectors, while [[m]] counts the number of active
vectors. [[k]] denotes the number of equations found for the current slice.

Here is the high-level structure of the algorithm:

<<Run the test>>=
u8 state[256];
RC4_keysetup(state, 0);
for (u32 n = 100000; n < 200000; n++) {
	double R = 64. / n;
	double expected_w = ceil(n * GV(R));
	printf("* %d, %.f\n", n, expected_w);
	for (u32 loops = 0; loops < 10; loops++) {
		u32 Wait[n];
		for (u32 i = 0; i < n; i++)
			Wait[i] = 0;
		<<Assemble the matrix [[M]]>>
		u32 best_weight = n;
		u32 MAX_ITERATIONS = 1 << 20;
		double start = wtime();
		u32 it;
		for (it = 0; it < MAX_ITERATIONS; it++) {
			<<Randomly permute 64 rows to the top>>
			<<Transpose [[M]] into [[T]]>>
			<<Echelonize [[T]]>>
			<<Check for low-weight vectors>>	
			if (best_weight <= expected_w + 1)
				break;
		}
		for (u32 i = 0; i < n; i++)
			if (Wait[i] > 0)
				printf("%d: %d\n", i, Wait[i]);
		printf("$ %.3f\n", wtime() - start);
		printf("# %d iterations (%.0f it/s)\n", it, it / (wtime() - start));
		printf("-----------------------\n");
	}
	
}

@ We define functions to help us compute expected bounds on the results. [[H]]
computes the binary entropy function, [[H_inv]] computes its reciprocal and
[[GV]] computes the Gilbert-Varshamov bound.

<<Functions>>=
double H(double x) {
	if (x == 0)
		return 0;
	if (x == 1)
		return 0;
	return -(x * log(x) + (1 - x) * log(1 - x)) / M_LN2;
}

<<Functions>>=
double H_inv(double y) {
	double a = 0;
	double b = 0.5;

	while (b - a > 1e-9) {
		const double x = (a + b) / 2;
		const double Hx = H(x);
		if (Hx < y)
			a = x;
		else
			b = x;
	}
	return (a + b) / 2;
}

<<Functions>>=
double GV(double R) {
	return H_inv(1 - R);
}


@ The matrix is $n \times 64$, but we pad it with zero rows until its size is
a multiple of 64. This way, the transpose of $M$ has 64 rows, each made of [[w]] columns.

<<Assemble the matrix [[M]]>>=
u32 w = ceil(n / 64.);
u32 rows = 64 * w;
u64 M[rows];
RC4_stream(state, (u8 *) M, 8 * n);
for (u32 i = n; i < rows; i++)
	M[i] = 0x0000000;


@ It is easier to permute the rows then transpose than to permute the columns
of the transposed matrix.

<<Functions>>=
static inline void swap(u64 *M, u32 i, u32 j)
{
	u64 tmp = M[i];
	M[i] = M[j];
	M[j] = tmp;
}

<<Randomly permute 64 rows to the top>>=
for (u32 i = 0; i < 64; i++) {
	u32 j = i + (lrand48() % (n - i));
	swap(M, i, j);
}

<<Transpose [[M]] into [[T]]>>=
u64 T[rows];
for (u32 i = 0; i < w; i++) {
	u64 S[64];
	transpose_64(M + i*64, S);
	for (u32 j = 0; j < 64; j++)
		T[i + j * w] = S[j];
}


@ OK, the matrix is transposed, so now we echelonize it. If all pivots cannot
be found in the first 64 columns, we abort. We keep an array indicating which
rows are pivotal (this dispenses us with pivoting the rows; it's a choice, not
sure it is the best one). In the end, we need to know how each resulting row
can be expressed as a linear combination of the input rows.

<<Echelonize [[T]]>>=
u64 E[64];
for (u32 i = 0; i < 64; i++)
	E[i] = 1ull << i;
for (i32 j = 0; j < 64; j++) {
	i32 i = -1;
	u64 mask = 1ull << j;
	while (i < 0) {
		<<If there is a pivot on column [[j]], let [[i]] be its rows and [[break]]>>
		<<Choose a column $k > 64$ at random; Permute columns [[j]] and [[k]]>>
	}
	<<Permute newly found pivotal row with row [[j]]>>
	<<Eliminate everything on column [[j]]>>
}


<<If there is a pivot on column [[j]], let [[i]] be its rows and [[break]]>>=
u32 ptr = 0;
for (i32 k = j; k < 64; k++) {
	if (((T[ptr] & mask) != 0)) {
		i = k;
		break;
	}
	ptr += w;
}
if (i >= 0)
	break;


<<Choose a column $k > 64$ at random; Permute columns [[j]] and [[k]]>>=
i32 k = 64 + (lrand48() % (n - 64));
i32 kw = k / 64;
i32 kbit = k % 64;
u32 ptr_swap = 0;
u64 *Tk = T + kw;
for (u32 i = 0; i < 64; i++) {
	u64 a = T[ptr_swap];
	u64 b = Tk[ptr_swap];
	u64 delta = ((a >> j) ^ (b >> kbit)) & 1;
	a ^= delta << j;
	b ^= delta << kbit;
	T[ptr_swap] = a;
	Tk[ptr_swap] = b;
	ptr_swap += w;
}

<<Permute newly found pivotal row with row [[j]]>>=
if (j != i) {
	swap(E, i, j);
	for (u32 k = 0; k < w; k++)
		swap(T, i * w + k, j * w + k);
}

<<Eliminate everything on column [[j]]>>=
u32 ptr_k = 0;
u32 ptr_i = i * w;
for (i32 k = 0; k < 64; k++) {
	if ((k != i) & ((T[ptr_k] & mask) != 0)) {
		for (u32 j = 0; j < w; j++)
			T[ptr_k + j] ^= T[ptr_i + j];
		E[k] ^= E[i];         /* record the operation */
	}
	ptr_k += w;
}


<<Check for low-weight vectors>>=
u32 ptr = 0;
for (u32 i = 0; i < 64; i++) {
	u32 weight = 1;
	for (u32 j = 1; j < w; j++)
		weight += __builtin_popcountll(T[ptr + j]);
	if (weight < best_weight) {
		printf("w = %d (%d iterations)\n", weight, it);
		best_weight = weight;
		Wait[weight] = it;
	}
	ptr += w;
}



@ To transpose, we start with an efficient $64 \times 64$ transpose routine
(using bitslice and ``magic masks'').

<<Functions>>=
static const uint64_t M1_HI = 0xffffffff00000000;
static const uint64_t M1_LO = 0x00000000ffffffff;
static const uint64_t M2_HI = 0xffff0000ffff0000;
static const uint64_t M2_LO = 0x0000ffff0000ffff;
static const uint64_t M3_HI = 0xff00ff00ff00ff00;
static const uint64_t M3_LO = 0x00ff00ff00ff00ff;
static const uint64_t M4_HI = 0xf0f0f0f0f0f0f0f0;
static const uint64_t M4_LO = 0x0f0f0f0f0f0f0f0f;
static const uint64_t M5_HI = 0xcccccccccccccccc;
static const uint64_t M5_LO = 0x3333333333333333;
static const uint64_t M6_HI = 0xaaaaaaaaaaaaaaaa;
static const uint64_t M6_LO = 0x5555555555555555;

<<Functions>>=
/* this code was written by Antoine Joux for his book 
  "algorithmic cryptanalysis" (cf. http://www.joux.biz). It
  was slighlty modified by C. Bouillaguet. Just like the original, it is licensed 
  under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License. */

void transpose_64(u64 *M, u64 *T)
{
	<<Transpose 32-bit blocks>>
	<<Transpose 16-bit blocks>>
	<<Transpose 8-bit blocks>>
	<<Transpose 4-bit blocks>>
	<<Transpose 2-bit blocks>>
	<<Transpose 1-bit blocks>>
}

<<Transpose 32-bit blocks>>=
/* to unroll manually */
for (int l = 0; l < 32; l++) {
	T[l] = (M[l] & M1_LO) | ((M[l + 32] & M1_LO) << 32);
	T[l + 32] = ((M[l] & M1_HI) >> 32) | (M[l + 32] & M1_HI);
}

<<Transpose 16-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 32)
	for (int l = l0; l < l0 + 16; l++) {
		uint64_t val1 = (T[l] & M2_LO) | ((T[l + 16] & M2_LO) << 16);
		uint64_t val2 = ((T[l] & M2_HI) >> 16) | (T[l + 16] & M2_HI);
		T[l] = val1;
		T[l + 16] = val2;
	}

<<Transpose 8-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 16)
	for (int l = l0; l < l0 + 8; l++) {
		uint64_t val1 = (T[l] & M3_LO) | ((T[l + 8] & M3_LO) << 8);
		uint64_t val2 = ((T[l] & M3_HI) >> 8) | (T[l + 8] & M3_HI);
		T[l] = val1;
		T[l + 8] = val2;
	}

<<Transpose 4-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 8)
	for (int l = l0; l < l0 + 4; l++) {
		uint64_t val1 = (T[l] & M4_LO) | ((T[l + 4] & M4_LO) << 4);
		uint64_t val2 = ((T[l] & M4_HI) >> 4) | (T[l + 4] & M4_HI);
		T[l] = val1;
		T[l + 4] = val2;
	}

<<Transpose 2-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 4)
	for (int l = l0; l < l0 + 2; l++) {
		uint64_t val1 = (T[l] & M5_LO) | ((T[l + 2] & M5_LO) << 2);
		uint64_t val2 = ((T[l] & M5_HI) >> 2) | (T[l + 2] & M5_HI);
		T[l] = val1;
		T[l + 2] = val2;
	}

<<Transpose 1-bit blocks>>=
for (int l = 0; l < 64; l += 2) {
	uint64_t val1 = (T[l] & M6_LO) | ((T[l + 1] & M6_LO) << 1);
	uint64_t val2 = ((T[l] & M6_HI) >> 1) | (T[l + 1] & M6_HI);
	T[l] = val1;
	T[l + 1] = val2;
}

@ Now, to transpose the $n \times 64$ matrix, we transpose each slice of 64
rows. It may have been smarter to add a ``row stride'' argument to the core
transpose function.

<<Functions>>=
void print_matrix(int n, int m, u64 *M)
{
	for (int i = 0; i < n; i++) {
		printf("%4d: ", i);
		for (int j = 0; j < m; j++)
			printf("%016" PRIx64 " ", M[i*m + j]);
		printf("\n");
	}
}


@

\end{document}
