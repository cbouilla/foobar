\documentclass{article}

\usepackage[a4paper,vmargin=1in]{geometry}
\usepackage{noweb}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{parskip}
\usepackage{xspace}
\usepackage{hyperref}

\begin{document}

\title{Solving Instances of the \textsf{3XOR} Problem: Datastructures}
\author{Charles Bouillaguet}

\maketitle

This file describes data structures with the following specification. 
$\mathcal{D}$ holds a small set of [[uint64_t]]. There will be many 
\emph{trials} ``does $x \in \mathcal{D}$?''. In $99.99999\%$ of the case, the 
answer is NO. So, the datastructure is optimized to answer as quickly as 
possible in this case. False positives are allowed (i.e. giving the answer YES 
while it is in fact NO), but false negatives are forbidden.

A (more expensive) deterministic check is performed when the answer is YES, so 
the rate of false positives has to be kept low.

This is akin to a bloom filter, but bloom filters are too slow for our purposes.

Several options are possible :
\begin{enumerate}
\item Linear Hashing (no false positives)
\item Cuckoo Hashing (no false positives, faster, more complicated)
\item Bloom filter (some false positives)
\item Cuckoo Filter (some false positives)
\end{enumerate}

<<datastructures.c>>=
#include <stdlib.h>
#include <err.h>
#include "datastructures.h"
<<Public functions>>

<<datastructures.h>>=
#include <inttypes.h>
#include <stdbool.h>
<<Type definitions>>
<<Function declarations>>

@ \section{Linear Hashing}

This section describes a hash table using linear probing (cf. Knuth). 
The size of the table is a power of two. We assume that 0 does not belong to the hash 
table, because 0 denotes empty cells. This is enforced during hash table build.
The hash table is fully described by a correctly initialized array of 64-bits 
integers and its size.

<<Type definitions>>=
struct hash_table_t {
	uint64_t mask;
	uint64_t *H;    // of size mask + 1
};

<<Function declarations>>=
int hashtable_size(int n_items);
struct hash_table_t * hashtable_build(uint64_t * const L, uint64_t lo, uint64_t hi);
void hashtable_free(struct hash_table_t *s);


@ Probing the hash table is simple... But will most certainly cause branch 
mispredictions, as the number of iterations of the [[while]] loop is impredictable. 
Because this has to be reeeaaaally, it is defined in the [[.h]] file to allow inlining.

<<Function declarations>>=
static inline bool hashtable_lookup(const struct hash_table_t *s, const uint64_t x)
{
	uint64_t h = x & s->mask;
	uint64_t probe = s->H[h];
	while (probe) {
		if (probe == x)
			return true;
		h = (h + 1) & s->mask;
		probe = s->H[h];
	}
	return false;
}

<<Public functions>>=
void hashtable_free(struct hash_table_t *s)
{
	free(s->H);
	free(s);
}


@ Building the hash table is not much more complicated, and in our case it is static. 
The size of the hash table then has to be chosen at build time. We choose it so that 
the fill ratio is less than 0.25. This ensures that probing stops after less than 
$\approx 2.5$ probes. To enable the use of efficient arithmetic, we use a table size 
which is a power of two. We thus determine the smallest power of two larger that $4n$. 
This gives satisfactory results, and it gets even better when the fill ratio goes down 
to $1/8$.

<<Public functions>>=
int hashtable_size(int n_items)
{
	int tmp = 4 * n_items + 1;
	int i = 0;
	while (tmp) {
		tmp >>= 1;
		i++;
	}
	return 1 << i;	
}

@ The function takes a sequence $L$ of 64-bits integers and returns a hash table. 

<<Public functions>>=
struct hash_table_t * hashtable_build(uint64_t * const L, uint64_t lo, uint64_t hi)
{
	struct hash_table_t *s = malloc(sizeof(*s));
	int size = hashtable_size(hi - lo);
	<<Initialize empty hash table>>
	for (uint64_t i = lo; i < hi; i++) {
		if (L[i] == 0)
			errx(1, "cannot insert 0 in hash table");
		<<insert [[L[i]]] into the hash table>>
	}
	s->H = H;
	s->mask = mask;
	return s;
}


<<Initialize empty hash table>>=
uint64_t mask = ((uint64_t) size) - 1;
uint64_t *H = malloc(size * sizeof(uint64_t));
if (H == NULL)
	err(1, "cannot allocate linear hash table");
for (int i = 0; i < size; i++)
	H[i] = 0;

@ Insertion is similar to probing: we find the first possible empty space, and 
we put the value there.

<<insert [[L[i]]] into the hash table>>=
uint64_t h = L[i] & mask;
while (H[h] != 0)
	h = (h + 1) & mask;
H[h] = L[i];



@ For now... let's use this as our final data structure.
 
\end{document}