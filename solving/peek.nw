\documentclass{article}

\usepackage{noweb}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{parskip}
%\usepackage[pdftex]{hyperref}
\def\cweb{{\tt noweb\/}}
\newcommand{\ZMQ}{\textsf{$\varnothing$MQ}}

\begin{document}

\title{An Application-Agnostic Task Server \\ (Peeking through solutions) }
\author{Charles Bouillaguet}

\maketitle

@ \section{Introduction}

This program demonstrates the ability to read the journal file during the
course of a long-running computation. This program does not do much; it just
computes the total size of all the tasks' results. The program has the usual
structure:

<<peek.c>>=
#define _XOPEN_SOURCE 500
<<Header files to include>>
<<Global variables>>
<<The main program>>

<<Header...>>=
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <getopt.h>
#include <err.h>
#include "server.h"


<<Global...>>=
int total_result_size = 0;
double total_time = 0.0;
int n_tasks = 0;

<<The main...>>=
int main(int argc, char **argv)
{
        <<Process the command line>>
        <<Parse the journal file>>
        <<Report>>
}

@ Each task result is read from the journal, and the following statistics are.

<<Accumulate statistics>>=
total_time += task.completion_time - task.start_time;
total_result_size += result.size;
n_tasks++;

@ The only command-line argument is the name of the journal file.

<<Process the command...>>=
struct option longopts[2] = {
	{"journal", required_argument, NULL, 'j'},
	{NULL, 0, NULL, 0}
};
char *journal_filename = NULL;
char ch;
while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) {
    	switch (ch) {
	case 'j':
		journal_filename = optarg;
		break;
	default:
		errx(1, "Unknown option\n");
	}
}
if (journal_filename == NULL)
	errx(1, "missing required option --journal=...");


@ Now the ``meat'', so to say, of the program. We open the journal and read
it. This is not very DRY with respect to the code of the server. Here, we
ignore the actual content of task's payloads.

<<Parse the journal...>>=
FILE *f = fopen(journal_filename, "r");
if (!f)
	err(1, "opening %s", journal_filename);
while (1) {
	<<Read a [[task_msg_t]]...>>
	<<Read the [[hostname]]>>
	<<Read a [[result_t]] and skip the payload>>
	<<Accumulate...>>
}
fclose(f);


<<Read a [[task_msg_t]]; if [[EOF]] then exit the loop>>=
struct task_msg_t task;
if (fread(&task, sizeof(task), 1, f) != 1) {
	if (feof(f))
		break;
	else 
		err(1, "reading journal file");
}

<<Read the [[hostname]]>>=
char hostname[HOST_NAME_MAX];
if (task.hostname_length > HOST_NAME_MAX)
	errx(1, "hostname too long");
size_t tmp = fread(hostname, 1, task.hostname_length, f);
if (tmp != task.hostname_length)
	err(1, "reading hostname");

<<Read a [[result_t]] and skip the payload>>=
struct result_t result;
if (fread(&result, sizeof(result), 1, f) != 1)
	err(1, "reading journal file (result)");
if (fseek(f, result.size, SEEK_CUR))
	err(1, "fseek, skipping over payload");

<<dump>>=
printf("%d;%s;%.1f;%.1f\n", record.id, hostname, record.start_time, record.duration);

<<Report>>=
fprintf(stderr, "Read %d tasks.\n", n_tasks);
fprintf(stderr, "%.1fs s in computation.\n", total_time);
fprintf(stderr, "%d bytes of results.\n", total_result_size);
return(EXIT_SUCCESS);

@
\end{document}

