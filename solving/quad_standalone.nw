\documentclass{article}

\usepackage[a4paper,vmargin=1in]{geometry}
\usepackage{noweb}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{parskip}
\usepackage{xspace}
\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}




\begin{document}

\title{Solving Instances of the \textsf{3XOR} Problem: \\ a Standalone Driver for the Quadratic Algorithm}
\author{Charles Bouillaguet}

\maketitle

\section{Introduction}

This file describes a standalone program that solves whole instances using the quadratic algorithm on a single core.

<<*>>=
#include <inttypes.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <err.h>
#include <getopt.h>
#include <string.h>
#include "common.h"
#include "datastructures.h"

extern struct task_result_t * quadratic_task(struct context_t *ctx, struct task_t *task);

<<The main function>>

@

<<The main function>>=
int main(int argc, char **argv)
{
	<<Process the command line>>
	<<Prepare the context>>
	<<Display some info>>
	<<Process all the tasks>>
	<<Display timing results>>
}



<<Process the command line>>=
struct option longopts[4] = {
	{"task-size", required_argument, NULL, 'k'},
	{"grid-size", required_argument, NULL, 'l'},
	{"index-depth", required_argument, NULL, 'd'},
	{NULL, 0, NULL, 0}
};
int k = -1;
int l = -1;
int depth = -1;
char ch;
while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) {
    	switch (ch) {
	case 'd':
		depth = atoi(optarg);
		break;
	case 'k':
		k = atoi(optarg);
		break;
	case 'l':
		l = atoi(optarg);
		break;
	default:
		errx(1, "Unknown option\n");
	}
  }
if (depth < 0)
	errx(1, "missing option --index-depth");
if (k < 0)
	errx(1, "missing option --task-size");
if (l < 0)
	errx(1, "missing option --grid-size");
if (argc - optind != 3)
	errx(1, "missing (or extra) hash filenames");
if (k + l > depth)
	errx(1, "k + l must be <= depth");


<<Prepare the context>>=
struct context_t ctx;
ctx.l = l;
ctx.depth = depth;
char **hash_filename = argv + optind;
uint32_t N[3];
for (int kind = 0; kind < 3; kind++) {
	<<Open hash file>>
	<<Load index file>>
}


<<Open hash file>>=
ctx.files[kind] = fopen(hash_filename[kind], "r");
if (ctx.files[kind] == NULL)
	err(1, "cannot open %s for reading", hash_filename[kind]);


<<Load index file>>=
char index_filename[strlen(hash_filename[kind]) + 7];
sprintf(index_filename, "%s.index", hash_filename[kind]);
FILE *f = fopen(index_filename, "r");
if (f == NULL)
	err(1, "Cannot open %s for reading", index_filename);
ctx.indexes[kind] = malloc((1 << depth) * sizeof(uint32_t));
if (ctx.indexes[kind] == NULL)
	err(1, "cannot allocate index");
size_t size = 1 + (1 << depth);
size_t check = fread(ctx.indexes[kind], sizeof(uint32_t), size, f);
if (check != size)
	errx(1, "incomplete index read (%zd vs %zd)", check, size);
fclose(f);
N[kind] = ctx.indexes[kind][size - 1];


<<Display some info>>=
	/* task-level */
double tasksize = (1 << k);
double mbytes = 8 * (N[0] + N[1] + N[2]) / tasksize / 1048576;
double mpairs = (N[1] / tasksize) * (N[2] / tasksize) / 1048576; 
printf("\n");
printf("Average task volume : %.1fMbyte of hashes, %.1fMpair\n", mbytes, mpairs);
	/* block-level */
double blocksize = (1 << (k + l));
double shared_slice = N[0] / blocksize;
int hash_size = hashtable_size(shared_slice);
printf("Average block slice volume : %.0f bytes (%.0f hashes). |hash| = %d entries (%d bytes)\n", 
	8 * shared_slice, shared_slice, hash_size, 8 * hash_size);
	/* chunk-level */
double kbytes = 8 * (N[0] + N[1] + N[2]) / blocksize / 1024;
mpairs = (N[1] / tasksize) * (N[2] / blocksize) / 1048576; 
printf("Average chunk volume : %.1fKbyte of hashes, %.1fMpair\n", kbytes, mpairs);
printf("\n");


<<Process all the tasks>>=
double start = wtime();
uint64_t clock = ticks();
int problem_size = 1 << k;
for (int i = 0; i < problem_size; i++)
	for (int j = 0; j < problem_size; j++) {
		struct task_t task;
		task.k = k;
		task.idx[0] = i;
		task.idx[1] = j;
		task.idx[2] = i ^ j;
		printf("task (%d, %d) : ", i, j);
		fflush(stdout);
		struct task_result_t *solutions = quadratic_task(&ctx, &task);
		printf("%d solutions\n", solutions->size);
		for (int u = 0; u < solutions->size; u++)
			printf("%016" PRIx64 " ^ %016" PRIx64 " ^ ... == 0\n",
				solutions->solutions[u].x, solutions->solutions[u].y);
		free(solutions->solutions);
		free(solutions);
	}

<<Display timing results>>=
double wall = wtime() - start;
uint64_t cycles = ticks() - clock;
double n_pairs = (1.0 * N[1]) * (1.0 * N[2]);
double rate = n_pairs / wall;
double inv_throughput = cycles / n_pairs;
printf("Wall time: %.1fs, %" PRId64 " CPU ticks.\n", wall, cycles);
printf("Rate: %.1fMpair/s / %.1f cycle/pair.\n", rate / (1024 * 1024), inv_throughput);


@ 
\end{document}