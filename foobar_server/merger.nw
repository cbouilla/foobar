\documentclass{article}
\usepackage{noweb}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{textcomp}
\usepackage{parskip}
\usepackage{geometry}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{hyperref}

\def\noweb{{\tt noweb\/}}
\newcommand{\join}{\bowtie}

\newcommand{\ZMQ}{\textsf{$\varnothing$MQ}\xspace}
\newcommand{\NN}{\textsf{nanomsg}\xspace}
\newcommand{\MPI}{\textsf{MPI}\xspace}
\newcommand{\OMP}{\textsf{OpenMP}\xspace}

\begin{document}

\title{Tools for the \texttt{FOOBAR}-modified Miner: Merger}
\author{Charles Bouillaguet}

\maketitle

This program takes sorted split dictionnary files and writes down a
\textbf{hash file} (i.e. a sequence of [[uint64_t]]) in ascending order,
without duplicates. It mostly implements a multi-way merge. This process is
certainly IO bound, yet we did not make any effort to overlap IO and
computation.



<<Type definitions>>=
struct preimage_t {
	int64_t counter;
	uint32_t nonce;
} __attribute__((packed));

struct dict_t {
	uint64_t hash;
	struct preimage_t preimage;
} __attribute__((packed));


@ This program reads many dictionnary file and merge/deduplicate them.

<<*>>=
<<Header files to include>>
<<Type definitions>>
<<Auxiliary functions>>
<<The main program>>

@ We need the usual standard headers.

<<Header files to include>>=
#define _XOPEN_SOURCE 500
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <err.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/time.h>


@ We use a small function to measure the passage of time accurately.

<<Auxiliary functions>>=
double wtime()
{
	struct timeval ts;
	gettimeofday(&ts, NULL);
	return (double)ts.tv_sec + ts.tv_usec / 1E6;
}


<<The main program>>=
int main(int argc, char **argv)
{
	<<Process the command line>>
	<<Open all files>>
	<<Merge input dictionnaries>>
	<<Close all files>>
	exit(EXIT_SUCCESS);
}

@ The name of input and output files are given on the command-line. Let us deal with the technicalities first.

<<Process the command line>>=
struct option longopts[2] = {
	{"output", required_argument, NULL, 'o'},
	{NULL, 0, NULL, 0}
};
char *out_filename = NULL;
signed char ch;
while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) {
	switch (ch) {
	case 'o':
		out_filename = optarg;
		break;
	default:
		errx(1, "Unknown option\n");
	}
}
if (out_filename == NULL)
	errx(1, "missing --output FILE");
if (optind >= argc)
	errx(1, "missing input filenames");
int P = argc - optind;
char **in_filenames = argv + optind;

<<Open all files>>=
FILE *f_in[P];
for (int i = 0; i < P; i++) {
	f_in[i] = fopen(in_filenames[i], "r");
	if (f_in[i] == NULL)
		err(1, "cannot open %s for reading", in_filenames[i]);
}

FILE *f_out = fopen(out_filename, "w");
if (f_out == NULL)
	err(1, "cannot open %s for writing", out_filename);

<<Close all files>>=
for (int i = 0; i < P; i++)
	if (fclose(f_in[i]))
		err(1, "fclose on %s", in_filenames[i]);
if (fclose(f_out))
	err(1, "fclose on %s", out_filename);


@ The actual ``meat" of the program is the $P$-way merge procedure. Two
options present themselves: using a heap or a tournament tree. We chose the
latter (somewhat arbitrarily). This implementation is based on Knuth's
``replacement selection'' algorithm.

We maintain a binary tree with $P$ internal nodes and $P$ leaves. The $i$-th
leave is associated with the $i$-th input file. Each internal node contains
two fields: the loser of the match between its two children and the ``input
file index'' of this value. Nodes are numbered from $1$ to $P$, so that the
parent of [[i]] is [[i / 2]], the left children is [[2 * i]] and the right
children is [[2 * i  +1]]. A special zero-th node contains the winner of the
tournament (the smallest hash).

Each leaf of the tree is attached to a buffer, read from the $i$-th input
file. We use the special value [[0xffffffffffffffff]] as a sentinel to mark
the end of each files. At all times, the ``champion'' (smallest hash) is in
[[Q]] and its file of origin is in [[i]].

<<Merge input dictionnaries>>=
static const uint64_t SENTINEL = 0xffffffffffffffffull;
<<Allocate buffers>>
<<Initialize the tournament tree>>
while (Q < SENTINEL) {
	<<Append [[Q]] to the output buffer if not duplicate>>
	<<If the [[i]]-th input buffer is empty, try to refill it>>
	<<Read the next hash from the [[i]]-th buffer into [[Q]]>>
	<<Update tournament tree ; update [[Q]] and [[i]]>>
}
<<Flush the output buffer to disk>>
printf("\n");

@ Let us start with the setup. We need one input buffer for each input file,
and one output buffer. We must be careful that these buffer may not be full,
and will be partially consumed.

<<Allocate buffers>>=
static const int OUT_BUFFER_SIZE = 131072;
static const int IN_BUFFER_SIZE = 52428;
struct dict_t *buffer_in[P];
int size_in[P], ptr_in[P];
for (int i = 0; i < P; i++) {
	buffer_in[i] = malloc(IN_BUFFER_SIZE * sizeof(struct dict_t));
	if (buffer_in[i] == NULL)
		err(1, "malloc failed (input buffer)");
	size_in[i] = 0;
	ptr_in[i] = 0;
}
uint64_t *buffer_out = malloc(OUT_BUFFER_SIZE * sizeof(uint64_t));
if (buffer_out == NULL)
	err(1, "malloc failed (output buffer)");
int ptr_out = 0;
int64_t flushed = 0;
double start = wtime();

@ Duplicates are detected on output. We simply keep the previous value
actually written and discard an eventual output if it is equal to this value.
As a bonus, initializing this to zero automatically discards the parasitic
inputs we used to build the tree! Writing the sorted elements to the output
file is easy. We take the opportunity to implement some verbosity.

<<Append [[Q]] to the output buffer if not duplicate>>=
// printf("taking %016" PRIx64 " from file %d\n", Q, i);
if (ptr_out == OUT_BUFFER_SIZE) {
	<<Flush the output buffer to disk>>
}
if (Q != Q_prev)
	buffer_out[ptr_out++] = Q;
else
	dupes++;
Q_prev = Q;


<<Flush the output buffer to disk>>=
flushed += ptr_out;
size_t check_out = fwrite(buffer_out, sizeof(*buffer_out), ptr_out, f_out);
if (check_out != (size_t) ptr_out)
	err(1, "fwrite inconsistency : %zd vs %d", check_out, ptr_out);
ptr_out = 0;
double mhash = flushed * 1e-6;
double rate = mhash / (wtime() - start);
printf("\rItem processed: %.1fM (%.1fM/s)  duplicates=%d,   IN=%.1f Mb/s   OUT =%.1f Mb/s", mhash, rate, dupes, 20*rate, 8*rate);
fflush(stdout);



@ To bootstrap the tree construction, we use a trick: we create $P$ fake
records whose hash is set to zero, each supposedly originating from a
different input file. We will \emph{not} write these special zero hashes to
the output. But ``extracting" them from the tree will cause a fresh, actual
value to be fetched from each input file.

<<Initialize the tournament tree>>=
uint64_t loser[P];
int origin[P];
for (int j = 0; j < P; j++) {
	loser[j] = 0;
	origin[j] = j;
}
uint64_t Q = 0, Q_prev = 0;
int i = 0, dupes = 0;

@ Now that the top of the tree has been dealt with, we must replace it with a
new value from input buffer $i$. First, we take care of the fact that this
buffer may be empty.

<<If the [[i]]-th input buffer is empty, try to refill it>>=
if (ptr_in[i] == size_in[i]) {
	// printf("reading from %s\n", in_filenames[i]);
	size_in[i] = fread(buffer_in[i], sizeof(struct dict_t), IN_BUFFER_SIZE, f_in[i]);
	if (ferror(f_in[i]))
		err(1, "fread on %s", in_filenames[i]);
	ptr_in[i] = 0;
}

@ If refill was attempted but the buffer is still empty, we inject [[SENTINEL]].

<<Read the next hash from the [[i]]-th buffer into [[Q]]>>=
if (size_in[i] == 0)
	Q = SENTINEL;
else
	Q = buffer_in[i][ptr_in[i]++].hash;

@ And now the moment you have all been waiting for: the update of the
tournament tree. At this stage [[Q]] is no longer the champion.

<<Update tournament tree ; update [[Q]] and [[i]]>>=
int T = (P + i) / 2;
//printf("New value read from file %d: %016" PRIx64 ", injected in node %d\n", i, Q, T);
while (T >= 1) {
	//printf("update : comparing Q=%016" PRIx64 " with LOSER[%d]=%016" PRIx64" (origin=%d)\n", Q, T, loser[T], origin[T]);
	if (loser[T] < Q) {
		//printf("\tSWAP\n");
		uint64_t foo = loser[T];
		int bar = origin[T];
		loser[T] = Q;
		origin[T] = i;
		Q = foo;
		i = bar;
	}
	T = T / 2;
}
//printf("State: Q = %016" PRIx64", i = %d\n", Q, i);
//for (int j = 0; j < P; j++)
//	printf("LOSER[%d] = %016" PRIx64 " / ORIGIN[%d] = %d\n", j, loser[j], j, origin[j]);
//printf("=====================\n");

@

\end{document}
