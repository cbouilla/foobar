\documentclass{book}

\usepackage[a4paper]{geometry}
\usepackage{noweb}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{parskip}
\usepackage{xspace}
\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{decorations.pathreplacing}


\begin{document}
\setcounter{part}{2}
\part{The Iterated Joux \textsf{3XOR} Algorithm}
\chapter{Introduction}

As in the quadratic algorithm, for a given instance $(A, B, C)$ of the problem, 
we may split it into a 2D array of size $2^k \times 2^k$, where the 
sub-instance of coordinates $(i, j)$ is $(A^{[i]}, B^{[j]}, C^{[i \oplus j]})$.

This partition create sub-instances where $A_i$ and $B_j$ simultaneously have
the optimal size (roughly 1 Mbyte)  to be processed by a single core of
\texttt{turing}.

The \emph{task processing function} (described later) deals with such tasks.
They take as input two slices of $A$ and $B$ (along with their sizes) and a
preprocessed slice of $C$. A [[struct jtask_t]] contains all the necessary data.

<<Type definitions>>=
struct jtask_t {
	u64 *L[2];
	u64 n[2];
	struct slice_t *slices;
	u64 slices_size;
};

@ This header file is meant to be used by most code in here.

<<common.h>>=
#include <stdio.h>
#include "../types.h"

<<Type definitions>>
<<Function declarations>>

@ \section{Utilities}

We have the usual boilerplate.

<<*>>=
#define _POSIX_C_SOURCE 200112L
#include <stdlib.h>
#include <err.h>
#include <arpa/inet.h>
#include <byteswap.h>
#include <sys/stat.h>
#include <assert.h>

#include "common.h"
#include "papi.h"

<<Functions>>


@ Now, with the actual content. Let's begin with useful macros.

<<Function declarations>>=
#define MAX(x, y) (((x) < (y)) ? (y) : (x))
#define MIN(x, y) (((x) < (y)) ? (x) : (y))

// static inline u64 LEFT_MASK(u32 n)
// {
// 	return ~((1ull << (64 - n)) - 1);
// }

static inline u64 RIGHT_MASK(u32 n)
{
	return (1ull << n) - 1;
}

@ At the begining, there was time (and CPU cycles). Note that CPU cycles are
unreliable on x86 CPUs with ``turbo boost''.

<<Function declarations>>=
double wtime();
u64 cycles();

<<Functions>>=
double wtime()
{
	return PAPI_get_real_usec() / 1e6;
}

u64 cycles()
{
	return PAPI_get_real_cyc();
}

@ We need to know if we run on a little-endian machine (x86, etc.)  or a big-
endian machine (PowerPC). The test is simple: the network function converts to
network order(big-endian). If the result is different from the input, then we
are on a little-endian machine.

<<Function declarations>>=
bool big_endian();

<<Functions>>=
bool big_endian()
{
        return (htonl(0x47) == 0x47);
}

@ The IBM \texttt{xlc} compilers are not \textsf{C11}-compliant, therefore we
implement [[aligned_alloc]] ourselves...

<<Function declarations>>=
void * aligned_alloc(size_t alignment, size_t size);

<<Functions>>=
void * aligned_alloc(size_t alignment, size_t size)
{
        void *p;
        if (posix_memalign(&p, alignment, size) != 0)
                return NULL;
        return p;
}

@ The next utility function loads a sequence of [[u64]] from a file. The file
is assumed to be in \emph{little-endian} byte order. Therefore, the [[u64]]
are byteswapped if the machine is big-endian.

<<Function declarations>>=
void * load_file(const char *filename, u64 *size_);

<<Functions>>=
void * load_file(const char *filename, u64 *size_)
{
	struct stat infos;
	if (stat(filename, &infos))
		err(1, "fstat failed on %s", filename);
	u64 size = infos.st_size;
	assert ((size % 8) == 0);
	u64 *content = aligned_alloc(64, size);
	if (content == NULL)
		err(1, "failed to allocate memory");
	FILE *f = fopen(filename, "r");
	if (f == NULL)
		err(1, "fopen failed (%s)", filename);
	u64 check = fread(content, 1, size, f);
	if (check != size)
		errx(1, "incomplete read %s", filename);
	fclose(f);
	*size_ = size;
	<<if big-endian, byte-swap [[content]]>>
	return content;
}

<<if big-endian, byte-swap [[content]]>>=
if (big_endian()) {
	#pragma omp parallel for
	for (u32 i = 0; i < size / 8; i++)
		content[i] = bswap_64(content[i]);
}


@ \section{Handling Task Results}

Results are returned in a dynamic array. It grows automatically when necessary.

<<Type definitions>>=
struct solution_t {
	u64 x, y, z;           /* triplet in A x B x C */
};

struct task_result_t {
	u32 size;
	u32 capacity;
	struct solution_t *solutions;
};

<<Function declarations>>=
struct task_result_t * result_init();
void report_solution(struct task_result_t *result, u64 x, u64 y, u64 z);
void result_free(struct task_result_t *result);


<<Functions>>=
struct task_result_t * result_init()
{
	struct task_result_t *result = malloc(sizeof(*result));
	if (result == NULL)
		err(1, "cannot allocate task result object");
	result->size = 0;
	result->capacity = 128;
	result->solutions = malloc(result->capacity * sizeof(struct solution_t));
	return result;
}

void result_free(struct task_result_t *result)
{
	free(result->solutions);
	free(result);
}

@ Note that this function is not thread-safe.

<<Functions>>=
void report_solution(struct task_result_t *result, u64 x, u64 y, u64 z)
{
    if ((x ^ y ^ z) != 0)
	warnx("Fake solution reported");
    if (result->size == result->capacity) {
	result->solutions = realloc(result->solutions, 2 * result->capacity);
	if (result->solutions == NULL)
	    err(1, "failed to re-alloc solutions array");
	result->capacity *= 2;
    }
    result->solutions[result->size].x = x;
    result->solutions[result->size].y = y;
    result->solutions[result->size].z = z;
    result->size++;
}



@ \end{document}