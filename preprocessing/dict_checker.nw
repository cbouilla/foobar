\documentclass{article}
\usepackage{noweb}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{textcomp}
\usepackage{parskip}
\usepackage{geometry}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{hyperref}

\def\noweb{{\tt noweb\/}}
\newcommand{\join}{\bowtie}

\newcommand{\ZMQ}{\textsf{$\varnothing$MQ}\xspace}
\newcommand{\NN}{\textsf{nanomsg}\xspace}
\newcommand{\MPI}{\textsf{MPI}\xspace}
\newcommand{\OMP}{\textsf{OpenMP}\xspace}

\begin{document}

\title{Tools for the \texttt{FOOBAR}-modified Miner: Dictionnary Checker}
\author{Charles Bouillaguet}

\maketitle

This program checks that a \textbf{(split) dictionnary file} is correct (i.e.
the preimages are valid and the hash match). It will also detect if it is
sorted by increasing hashes, with or without duplicates.

This program takes the name of a single dictionnary file on the command-line.

<<*>>=
<<Header files to include>>
<<The main program>>

@ We need the usual standard headers.

<<Header files to include>>=
#define _XOPEN_SOURCE 500
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <err.h>
#include <getopt.h>
#include "hasher.h"

<<The main program>>=
int main(int argc, char **argv)
{
	<<Process the command line>>
	<<Open input file and allocate [[buffer]]>>
	struct dict_t prev = {0, {0, 0}};
	size_t processed = 0, size = 0;
	bool in_order = true;
	int full_dupes = 0, partial_dupes = 0;
	while (!feof(f)) {
		<<Fill [[buffer]] from input file>>
		<<Verify [[buffer]]>>
	}
	processed += size;
	fclose(f);
	printf("%zd items processed. In order: %d. Hash collisions: %d. Duplicate preimages: %d\n",
		processed, in_order, partial_dupes, full_dupes);
	exit(EXIT_SUCCESS);
}

<<Process the command line>>=
struct option longopts[2] = {
	{"kind", required_argument, NULL, 'k'},
	{NULL, 0, NULL, 0}
};
int kind = -1;
signed char ch;
while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) {
	switch (ch) {
	case 'k':
		kind = atoi(optarg);
		break;
	default:
		errx(1, "Unknown option\n");
	}
}
if (kind < 0)
	errx(1, "missing --kind");
if (optind >= argc)
	errx(1, "missing input filename");
char *in_filename = argv[optind];


<<Open input file and allocate [[buffer]]>>=
FILE *f = fopen(in_filename, "r");
if (f == NULL)
	err(1, "cannot open %s for reading", in_filename);
static const int BUFFER_SIZE = 131072;
struct dict_t *buffer = malloc(BUFFER_SIZE * sizeof(*buffer));
if (buffer == NULL)
	err(1, "cannot allocate buffer");


@ [[processed]] counts the number of items in previously processed buffers.
[[size]] is the size of the current buffer.

<<Fill [[buffer]] from input file>>=
processed += size;
size = fread(buffer, sizeof(*buffer), BUFFER_SIZE, f);
if (ferror(f))
	err(1, "fread failed");

<<Verify [[buffer]]>>=
for (size_t i = 0; i < size; i++) {
	/* check preimage validity */
	uint32_t full_hash[8];
	if (!compute_full_hash(kind, &buffer[i].preimage, full_hash))
		errx(1, "invalid preimage %zd", processed + i);
	if (buffer[i].hash != extract_partial_hash(full_hash))
		errx(1, "partial hash mismatch %zd", processed + i);
	if (prev.hash == buffer[i].hash)
		partial_dupes++;
	if (prev.hash > buffer[i].hash)
		in_order = false;
	if (prev.preimage.counter == buffer[i].preimage.counter && prev.preimage.nonce == buffer[i].preimage.nonce)
		full_dupes++;
	prev = buffer[i];
}

@

\end{document}
