\documentclass{book}
\usepackage{noweb}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{textcomp}
\usepackage{parskip}
\usepackage{geometry}
\usepackage{xspace}
\usepackage{hyperref}

\def\noweb{{\tt noweb\/}}
\newcommand{\join}{\bowtie}
\newcommand{\MaRI}{\textsf{M4RI}\xspace}

\newcommand{\ZMQ}{\textsf{$\varnothing$MQ}\xspace}
\newcommand{\NN}{\textsf{nanomsg}\xspace}
\newcommand{\MPI}{\textsf{MPI}\xspace}
\newcommand{\OMP}{\textsf{OpenMP}\xspace}

\begin{document}

\setcounter{chapter}{7}
\chapter{Slicer}

This program reads a $C$ hash file and partition it in \emph{slices}. A slice
is a sequence of [[u64]] such that their rank less than (or equal) to a given
threshold, which is approximately $\log_2 [[file size]]$. Then for each slice,
we computes the changes of bases and writes down a matrix file. We use \MaRI
to perform the linear algebra.

Each slice is represented by a [[struct slice_t]]. Slices are concatenated in
a \textbf{slice file}. Each fine task thus requires a single slice file. Slice
files are named [[slice/<key>]].


<<*>>=
#define _XOPEN_SOURCE 500   /* strdup */
#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>
#include <string.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>

#include <m4ri/m4ri.h>
#include "preprocessing.h"

<<Constants>>
<<Type definitions>>
<<Global variables>>
<<Functions>>
<<The main program>>

@ We need the usual standard headers.

<<The main program>>=
int main(int argc, char **argv)
{
	<<Process the command line>>
	<<Load the hash file; set up [[L]] and [[n]]>>
	<<Process all slices>>
	exit(EXIT_SUCCESS);
}

@ The only accepted command-line arguments is the name of file to process and
the number of bits to cancel in each slice [[--l]].

<<Process the command line>>=
struct option longopts[3] = {
	{"target-dir", required_argument, NULL, 't'},
	{"l", required_argument, NULL, 'l'},
	{NULL, 0, NULL, 0}
};
char *target_dir = NULL;
char *in_filename = NULL;
signed char ch;
i32 l = 0;
while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) {
	switch (ch) {
	case 't':
		target_dir = optarg;
		break;
	case 'l':
		l = atoi(optarg);
		break;
	default:
		errx(1, "Unknown option\n");
	}
}
if (optind >= argc)
	errx(1, "missing input file");
if (target_dir == NULL)
	errx(1, "missing --target-dir");
in_filename = argv[optind];


@ To read the hash file in memory, we first query its size, then
allocate memory accordingly, then finally read it in the allocated space.

FIXME : use the common function.

<<Load the hash file; set up [[L]] and [[n]]>>=
struct stat infos;
if (stat(in_filename, &infos))
	err(1, "fstat (%s)", in_filename);
u64 *L = malloc(infos.st_size);
if (L == NULL)
	err(1, "failed to allocate memory");
FILE *f_in = fopen(in_filename, "r");
if (f_in == NULL)
	err(1, "fopen failed");
size_t check = fread(L, 1, infos.st_size, f_in);
if ((check != (size_t) infos.st_size) || ferror(f_in))
	err(1, "fread : read %zd, expected %zd", check, infos.st_size);
if (fclose(f_in))
	err(1, "fclose %s", in_filename);
u32 n = infos.st_size / sizeof(*L);
if (l == 0) {
	l = ceil(log2(n));
	printf("using default l = %d\n", l);
}


@ \section{Processing the slices}

We install the input vectors in one of several a linked list: the [[active]]
and [[inactive]] ones. The lists have size $n + 1$ (we include an extra dummy
item at the begining so that they are never empty). At all times, [[n]] counts
the number of non-emited vectors, while [[m]] counts the number of active
vectors. [[k]] denotes the number of equations found for the current slice.

Here is the high-level structure of the algorithm:

<<Process all slices>>=
<<Setup linked lists>>
<<Mark all input vectors as ``active''>>
while (n > 0) {
	printf("Starting slice with %d active vectors\n", m);
	u64 equations[64];
	i32 k = 0; /* #equations */
	#if 0
	while (m >= MAX_ISD_INPUT) {
	 	<<Choose an index [[j]]>>
	 	<<Reject active vectors such $x_j = 1$>>
	}
	printf("Picked %d cheap equations, now %d active vectors remain\n", k, m);
	#endif
	while (k < l) {
		printf("Attacking %d active vectors with ISD (they live in a subspace of dimension %d\n", m, 64-k);
		<<Find an equation satisfied by a large number of active vectors>>
		<<Reject active vectors not satisfying the equation>>
		equations[k++] = best_equation;
		printf("Best weight=%d, equation=%" PRIx64 "\n", best_weight, best_equation);
		printf("Done an ISD pass. I now have %d equations and %d active vectors\n", k, m);
	}
	printf("Finished: I now have %d equations and %d active vectors\n", l, m);
	<<Output the slice>>
	<<Permute [[active]] and [[reject]]>>
}

@ The result of numerical simulations show that the best results are obtained,
in a given amount of time, by decoding up to the Gilbert-Varshamov bound
using the smallest possible length. The following value yields $2^{20}$ iterations.

<<Constants>>=
static const u32 MAX_ISD_ITERATIONS = 1024;

@ Let's start with the easy stuff, the linked lists.

<<Type definitions>>=
struct list_t {
	u64 x;
	struct list_t *next, *prev;
};

<<Functions>>=
void list_insert(struct list_t *list, struct list_t *item)
{
	item->next = list->next;
	item->prev = list;
	item->next->prev = item;
	item->prev->next = item;	
}

void list_remove(struct list_t *item)
{
	item->next->prev = item->prev;
	item->prev->next = item->next;
}

void list_clear(struct list_t *item)
{
	assert(item->x == 0);
	item->next = item;
	item->prev = item;
}

<<Global variables>>=
struct list_t *active, *reject;
u32 m;


<<Setup linked lists>>=
struct list_t *items = malloc(n * sizeof(*items));
if ((items == NULL))
	err(1, "cannot allocate linked lists");
struct list_t active_header, reject_header;
active = &active_header;
reject = &reject_header;
active->x = 0x00000000;
reject->x = 0x00000000;
list_clear(active);
list_clear(reject);


<<Mark all input vectors as ``active''>>=
for (u32 i = 0; i < n; i++) {
	items[i].x = L[i];
	list_insert(active, &items[i]);
}
free(L);
m = n;         // count of active vectors

@ Once everything is over, active vectors are emitted and rejected vectors
become active again.

<<Permute [[active]] and [[reject]]>>=
struct list_t *tmp = active;
active = reject;
reject = tmp;
list_clear(reject);
m = n;

@ Now, the ``cheap filtering'' step. Of course, we must not choose twice the
same index $j$, so we do a naive check. For convenience, we write two
functions. Filtering the active vectors with an arbitrary equation
demonstrates an iteration over the list.

<<Functions>>=
bool satisfy_equation(u64 x, u64 eq)
{
	return (__builtin_popcountll(x & eq) & 1) == 0;
}

void filter_active(u64 eq)
{
	struct list_t *item = active->next;
	while (item != active) {
		struct list_t *next = item->next;   /* we have to save this before modifying it */
		if (!satisfy_equation(item->x, eq)) {
			list_remove(item);
			list_insert(reject, item);
			m--;
		}
		item = next;	
	}
}

<<Choose an index [[j]]>>=
bool ok = false;
u64 eq;
while (!ok) {
	u32 j = lrand48() & 63;
	eq = 1ull << j;
	ok = true;
	for (u32 i = 0; i < k; i++)
		if (eq == equations[i]) {
			ok = false;
			break;
		}
}
equations[k++] = eq;

<<Reject active vectors such $x_j = 1$>>=
filter_active(eq);


@ Now comes the hard part. The active list has been reduced to a small number
of elements, and we are going to find a low-weight word in the code they
define. The current proposed strategy is to do a fixed number of iterations of
the Lee-Brickel algorithm, instead of iterating it until we get close enough
to the Gilbert-Varshamov bound. To avoid inifnite loops, a threshold would
eventually have had to be set.

When this starts, we know that all the active vectors live in a subspace of dimension $64 - k$.

<<Find an equation satisfied by a large number of active vectors>>=
double R = (64. - k) / m;
double expected_w = m * GV(R);
u64 expected_its = pow(2, m/20);
printf("length=%d, dimension=%d, Rate = %.3f, GV bound: %.1f, E[iterations] = %" PRId64 "\n", m, 64 - k, R, expected_w, expected_its);
<<Assemble the matrix [[M]]>>
u32 best_weight = m;
u64 best_equation = 0;
u32 n_iterations = (1 + k) * MAX_ISD_ITERATIONS;
for (u32 it = 0; it < n_iterations; it++) {
	<<Randomly permute $64 - k$ rows to the top>>
	<<Transpose [[M]] into [[T]]>>
	<<Echelonize [[T]]>>
	<<Check for low-weight vectors>>
}
printf("weight found = %d\n", best_weight);

@ We define functions to help us compute expected bounds on the results. [[H]]
computes the binary entropy function, [[H_inv]] computes its reciprocal and
[[GV]] computes the Gilbert-Varshamov bound.

<<Functions>>=
double H(double x) {
	if (x == 0)
		return 0;
	if (x == 1)
		return 0;
	return -(x * log(x) + (1 - x) * log(1 - x)) / M_LN2;
}

<<Functions>>=
double H_inv(double y) {
	double a = 0;
	double b = 0.5;

	while (b - a > 1e-9) {
		const double x = (a + b) / 2;
		const double Hx = H(x);
		if (Hx < y)
			a = x;
		else
			b = x;
	}
	return (a + b) / 2;
}

<<Functions>>=
double GV(double R) {
	return H_inv(1 - R);
}



@ The matrix is $n \times 64$, but we pad it with zero rows until its size is
a multiple of 64. This way, the transpose of $M$ has 64 rows, each made of [[w]] columns.

<<Assemble the matrix [[M]]>>=
u32 w = ceil(m / 64.);
u32 rows = 64 * w;
u64 M[rows];
u32 i = 0;
for (struct list_t *item = active->next; item != active; item = item->next)
	M[i++] = item->x;
assert(i == m);
while (i < rows)
	M[i++] = 0x0000000;

@ It is easier to permute the rows then transpose than to permute the columns
of the transposed matrix.


<<Functions>>=
static inline void swap(u64 *M, u32 i, u32 j)
{
	u64 tmp = M[i];
	M[i] = M[j];
	M[j] = tmp;
}

<<Randomly permute $64 - k$ rows to the top>>=
for (i32 i = 0; i < 64 - k; i++) {
	i32 j = i + (lrand48() % (m - i));
	swap(M, i, j);
}


<<Transpose [[M]] into [[T]]>>=
u64 T[rows];
for (u32 i = 0; i < w; i++) {
	u64 S[64];
	transpose_64(M + i*64, S);
	for (u32 j = 0; j < 64; j++)
		T[i + j * w] = S[j];
}

@ OK, the matrix is transposed, so now we echelonize it. If all pivots cannot
be found in the first columns, we pick another column from the rest of the
matrix.

<<Echelonize [[T]]>>=
u64 E[64];
for (u32 i = 0; i < 64; i++)
	E[i] = 1ull << i;
for (i32 j = 0; j < 64 - k; j++) {
	i32 i = -1;
	u64 mask = 1ull << j;
	while (i < 0) {
		<<If there is a pivot on column [[j]], let [[i]] be its rows and [[break]]>>
		<<Choose a column $\ell > 64 - k$ at random; Permute columns [[j]] and [[k]]>>
	}
	<<Permute newly found pivotal row with row [[j]]>>
	<<Eliminate everything on column [[j]]>>
}

<<If there is a pivot on column [[j]], let [[i]] be its rows and [[break]]>>=
for (i32 k = j; k < 64; k++) {
	if (((T[k * w] & mask) != 0)) {
		i = k;
		break;
	}
}
if (i >= 0)
	break;


<<Choose a column $\ell > 64 - k$ at random; Permute columns [[j]] and [[k]]>>=
i32 l = (64 - k) + (lrand48() % (m - (64 - k)));
i32 lw = l / 64;
i32 lbit = l % 64;
u64 *Tl = T + lw;
for (u32 i = 0; i < 64; i++) {
	u64 a = T[i * w];
	u64 b = Tl[i * w];
	u64 delta = ((a >> j) ^ (b >> lbit)) & 1;
	a ^= delta << j;
	b ^= delta << lbit;
	T[i * w] = a;
	Tl[i * w] = b;
}

<<Permute newly found pivotal row with row [[j]]>>=
if (j != i) {
	swap(E, i, j);
	for (u32 k = 0; k < w; k++)
		swap(T, i * w + k, j * w + k);
}

<<Eliminate everything on column [[j]]>>=
for (i32 k = 0; k < 64; k++) {
	if ((k != i) & ((T[k * w] & mask) != 0)) {
		E[k] ^= E[i];         /* record the operation */
		for (u32 j = 0; j < w; j++)
			T[k * w + j] ^= T[i * w + j];
	}
}


<<Check for low-weight vectors>>=
for (u32 i = 0; i < 64; i++) {
	u32 weight = 0;
	for (u32 j = 0; j < w; j++)
		weight += __builtin_popcountll(T[i * w + j]);
	if (0 < weight && weight < best_weight) {
		printf("w = %d (%d iterations)\n", weight, it);
		best_weight = weight;
		best_equation = E[i];
	}
}

@ Once an equation has been found, we reject vectors that do not satisfy it.
This is similar to what has been done before. 

<<Reject active vectors not satisfying the equation>>=
filter_active(best_equation);

@ The active vectors form a slice. We emit them and forget them.

<<Output the slice>>=
n -= m;
// actually do something!
for (i32 i = 0; i < l; i++)
	printf("eq[%d] = %016" PRIx64 "\n", i, equations[i]);

<<Open the output slice file>>=
char * key = strrchr(in_filename, '.');
if (key == NULL)
	errx(1, "ill-formated input filename");
char slice_filename[255];
sprintf(slice_filename, "%s/%s", target_dir, key);
FILE *f_out = fopen(slice_filename, "w");
if (f_out == NULL)
	err(1, "cannot open %s\n", slice_filename);


<<Set output>>=
out->n = height;
out->l = 64 - rank;
for (u32 i = 0; i < 64; i++)
	out->M[i] = mzd_row(Ltinv, i)[0];
for (u32 i = 0; i < 64; i++)
	out->Minv[i] = mzd_row(Lt, i)[0];
for (u32 i = 0; i < height; i++)
	out->CM[i] = mzd_row(CM, i)[0];

<<Check $CM$>>=
for (u32 i = 0; i < height; i++)
	assert((out->CM[i] & LEFT_MASK(out->l)) == 0);

<<Open output file>>=
char out_filename[256];
sprintf(out_filename, "%s.matrix", in_filename);
FILE *f_out = fopen(out_filename, "w");
if (f_out == NULL)
	err(1, "cannot create output file %s", out_filename);

<<Write output to the slice file>>=
u32 size = sizeof(*out) + height * sizeof(u64);
check = fwrite(out, 1, size, f_out);
if (check != size)
	err(1, "fwrite inconsistensy %zd vs %d", check, size);

<<Free memory>>=
mzd_free(A);
mzd_free(At);
mzd_free(Lt);
mzd_free(Ltinv);
mzd_free(CM);

@ \section{Transpose function}

@ To transpose, we start with an efficient $64 \times 64$ transpose routine
(using bitslice and ``magic masks'').

<<Functions>>=
static const uint64_t M1_HI = 0xffffffff00000000;
static const uint64_t M1_LO = 0x00000000ffffffff;
static const uint64_t M2_HI = 0xffff0000ffff0000;
static const uint64_t M2_LO = 0x0000ffff0000ffff;
static const uint64_t M3_HI = 0xff00ff00ff00ff00;
static const uint64_t M3_LO = 0x00ff00ff00ff00ff;
static const uint64_t M4_HI = 0xf0f0f0f0f0f0f0f0;
static const uint64_t M4_LO = 0x0f0f0f0f0f0f0f0f;
static const uint64_t M5_HI = 0xcccccccccccccccc;
static const uint64_t M5_LO = 0x3333333333333333;
static const uint64_t M6_HI = 0xaaaaaaaaaaaaaaaa;
static const uint64_t M6_LO = 0x5555555555555555;

<<Functions>>=
/* this code was written by Antoine Joux for his book 
  "algorithmic cryptanalysis" (cf. http://www.joux.biz). It
  was slighlty modified by C. Bouillaguet. Just like the original, it is licensed 
  under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License. */

void transpose_64(u64 *M, u64 *T)
{
	<<Transpose 32-bit blocks>>
	<<Transpose 16-bit blocks>>
	<<Transpose 8-bit blocks>>
	<<Transpose 4-bit blocks>>
	<<Transpose 2-bit blocks>>
	<<Transpose 1-bit blocks>>
}

<<Transpose 32-bit blocks>>=
/* to unroll manually */
for (int l = 0; l < 32; l++) {
	T[l] = (M[l] & M1_LO) | ((M[l + 32] & M1_LO) << 32);
	T[l + 32] = ((M[l] & M1_HI) >> 32) | (M[l + 32] & M1_HI);
}

<<Transpose 16-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 32)
	for (int l = l0; l < l0 + 16; l++) {
		uint64_t val1 = (T[l] & M2_LO) | ((T[l + 16] & M2_LO) << 16);
		uint64_t val2 = ((T[l] & M2_HI) >> 16) | (T[l + 16] & M2_HI);
		T[l] = val1;
		T[l + 16] = val2;
	}

<<Transpose 8-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 16)
	for (int l = l0; l < l0 + 8; l++) {
		uint64_t val1 = (T[l] & M3_LO) | ((T[l + 8] & M3_LO) << 8);
		uint64_t val2 = ((T[l] & M3_HI) >> 8) | (T[l + 8] & M3_HI);
		T[l] = val1;
		T[l + 8] = val2;
	}

<<Transpose 4-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 8)
	for (int l = l0; l < l0 + 4; l++) {
		uint64_t val1 = (T[l] & M4_LO) | ((T[l + 4] & M4_LO) << 4);
		uint64_t val2 = ((T[l] & M4_HI) >> 4) | (T[l + 4] & M4_HI);
		T[l] = val1;
		T[l + 4] = val2;
	}

<<Transpose 2-bit blocks>>=
for (int l0 = 0; l0 < 64; l0 += 4)
	for (int l = l0; l < l0 + 2; l++) {
		uint64_t val1 = (T[l] & M5_LO) | ((T[l + 2] & M5_LO) << 2);
		uint64_t val2 = ((T[l] & M5_HI) >> 2) | (T[l + 2] & M5_HI);
		T[l] = val1;
		T[l + 2] = val2;
	}

<<Transpose 1-bit blocks>>=
for (int l = 0; l < 64; l += 2) {
	uint64_t val1 = (T[l] & M6_LO) | ((T[l + 1] & M6_LO) << 1);
	uint64_t val2 = ((T[l] & M6_HI) >> 1) | (T[l + 1] & M6_HI);
	T[l] = val1;
	T[l + 1] = val2;
}

@ Now, to transpose the $n \times 64$ matrix, we transpose each slice of 64
rows. It may have been smarter to add a ``row stride'' argument to the core
transpose function.

<<Functions>>=
void print_matrix(int n, int m, u64 *M)
{
	for (int i = 0; i < n; i++) {
		printf("%4d: ", i);
		for (int j = 0; j < m; j++)
			printf("%016" PRIx64 " ", M[i*m + j]);
		printf("\n");
	}
}


@ \end{document}
