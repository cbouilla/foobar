\documentclass{article}% ===> this file was generated automatically by noweave --- better not edit it
\usepackage{noweb}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{textcomp}
\usepackage{parskip}
\usepackage{geometry}
\usepackage{tikz}
\usepackage{xspace}
\usepackage{hyperref}

\def\noweb{{\tt noweb\/}}
\newcommand{\join}{\bowtie}

\newcommand{\ZMQ}{\textsf{$\varnothing$MQ}\xspace}
\newcommand{\NN}{\textsf{nanomsg}\xspace}
\newcommand{\MPI}{\textsf{MPI}\xspace}
\newcommand{\OMP}{\textsf{OpenMP}\xspace}

\begin{document}

\title{Tools for the \texttt{FOOBAR}-modified Miner: Splitter}
\author{Charles Bouillaguet}

\maketitle

The combination of the \texttt{FOOBAR}-modified Miner and the
\texttt{FOOBAR}-server yields \emph{preimage files}, containing (counter,
nonce) pairs. In this document, we call this a \textbf{preimage}. Each pair
requires 12 bytes, and we expect to have 3 lists of $2^{31.7}$ entries each,
for a total storage space of 117Gbyte.

The nonce files must be checked (i.e. the corresponding hashes must have 32
zero bits). They must then be hashed, and 64 bits of each hash stored to disk.
This yields three hash lists, of $25.4$Gbyte each. These lists have to be
sorted and checked for duplicates. Thus in total, we expect to need $\approx
150$ Gbyte of storage.

Each preimage is associated to a 256-bit \textbf{full hash}, of which 33 at
least must be zero. From this full hash, we extract a subset of 64 (uniformly
distributed) bits that we call the \textbf{hash}.

For various reasons, we ensure that the hashes are unique. Because of the
large number of preimages, we might encounter accidental collisions, so we
must actively enforce this. We actually maintain a dictionnary ${\Tt{}hash\nwendquote}
\rightarrow {\Tt{}preimage\nwendquote}$, where the hashes are unique, and where it is fairly
easy to add new preimages and to extract all the hashes in sorted order.

The miner generates $\approx 550$ preimages per second, which means roughly
550 Mbyte per day of fresh data. Ideally, we would like the total amount of
work required to integrate this much data to the dictionnary to be as low as
possible.

We use the following strategy :

\begin{enumerate}  
\item When a new preimage file is ready, split it into several \textbf{split dictionnaries}
by partitionning the hashes according to most significant $b$ bits. This yields 
$2^b$ buckets. Potential duplicates are now confined into a single bucket.

\item Sort the newly formed split dictionnaries by hash. They must fit in RAM in 
order to do this easily, but they should be small.

\item For each bucket, perform a multiway merge on all split dictionnaries. 
Detect duplicate hashes and write down the hashes in order into a \textbf{hash file}.
\end{enumerate}

Concretely, a preimage file contains a sequence of {\Tt{}struct\ preimage{\_}t\nwendquote}. A
split dictionnary contains a sequence of {\Tt{}dict{\_}t\nwendquote}. These types are described in {\Tt{}hasher.h\nwendquote}.


\nwfilename{splitter.nw}\nwbegindocs{1}The main strategy is as follows. A "reader" reads the input file and sends
blocks of (counter, nonce) pairs to "mappers". Each mapper assembles the
plaintext block, hash it, and dispatch it in one of each buffers. When a
buffer is full, it is flushed to a "writter".

We considered several options. 

OPTION A: each "worker" is a thread. Threads interract through (concurrent)
\emph{queues}. The reader thread pushes blocks to a single-writter multiple-
readers queue. The mapper threads pull from this queue and push to several
multiple-writer single-reader queues (one for each writer thread). The queues
are partial and bounded. These queues could be implemented by hand (using
locks and semaphores, for instance), or could be built using a messaging
middleware such as \ZMQ or \NN. Threads could be managed using the {\Tt{}pthread\nwendquote}
standard library or using something like \OMP.

OPTION B: each "worker" is a process. Processes interact through the \MPI
messaging library, using asynchronous IO if possible.

We chose option B, because it is simpler.

\section{Global Structure}

This program reads a preimage file, and compute all the hashes. It checks that
the (counter, nonce) pairs indeed yield hashes with 32 leading zero bits, and
dispatches the dictionnary items into split dictionnary files.

\nwenddocs{}\nwbegincode{2}\sublabel{NW12oR4B-1p0Y9w-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-1p0Y9w-1}}}\moddef{*~{\nwtagstyle{}\subpageref{NW12oR4B-1p0Y9w-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}Header files to include~{\nwtagstyle{}\subpageref{NW12oR4B-4BXCU3-1}}\RA{}
\LA{}Global variables~{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}\RA{}
\LA{}The main program~{\nwtagstyle{}\subpageref{NW12oR4B-4O9khr-1}}\RA{}

\nwnotused{*}\nwendcode{}\nwbegindocs{3}We need the usual standard headers.

\nwenddocs{}\nwbegincode{4}\sublabel{NW12oR4B-4BXCU3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-4BXCU3-1}}}\moddef{Header files to include~{\nwtagstyle{}\subpageref{NW12oR4B-4BXCU3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwenddeflinemarkup
#define _XOPEN_SOURCE 500
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <err.h>
#include <inttypes.h>
#include <getopt.h>
#include <assert.h>
#include <libgen.h>

#include <mpi.h>
#include "hasher.h"


\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegincode{5}\sublabel{NW12oR4B-4O9khr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-4O9khr-1}}}\moddef{The main program~{\nwtagstyle{}\subpageref{NW12oR4B-4O9khr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwenddeflinemarkup
int main(int argc, char **argv)
\{
        \LA{}Initialization~{\nwtagstyle{}\subpageref{NW12oR4B-3zYZcV-1}}\RA{}
        \LA{}Process the command line~{\nwtagstyle{}\subpageref{NW12oR4B-9FeVG-1}}\RA{}
        \LA{}Finish setup~{\nwtagstyle{}\subpageref{NW12oR4B-45A6xH-1}}\RA{}
        \LA{}Start reader, mappers and writers~{\nwtagstyle{}\subpageref{NW12oR4B-3hmYEA-1}}\RA{}
        MPI_Finalize();
        exit(EXIT_SUCCESS);
\}

\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegindocs{6}The possible command-line arguments are the kind of the blocks  ({\Tt{}FOO\nwendquote},
{\Tt{}BAR\nwendquote}, {\Tt{}FOOBAR\nwendquote}), the $\log_2$ of the number of output hash files and the
input nonce filenames. We enforce that the arguments are actually present. An
optionnal argument specifies the output directory of the split dictionnary
files.

\nwenddocs{}\nwbegincode{7}\sublabel{NW12oR4B-20zlE5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwprevnextdefs{\relax}{NW12oR4B-20zlE5-2}\nwenddeflinemarkup
struct option longopts[4] = \{
        \{"kind", required_argument, NULL, 'k'\},
        \{"bits", required_argument, NULL, 'b'\},
        \{"output-dir", required_argument, NULL, 'd'\},
        \{NULL, 0, NULL, 0\}
\};
int kind = -1;
int bits = -1;
char *output_dir = NULL;

\nwalsodefined{\\{NW12oR4B-20zlE5-2}\\{NW12oR4B-20zlE5-3}\\{NW12oR4B-20zlE5-4}\\{NW12oR4B-20zlE5-5}}\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegincode{8}\sublabel{NW12oR4B-9FeVG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-9FeVG-1}}}\moddef{Process the command line~{\nwtagstyle{}\subpageref{NW12oR4B-9FeVG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-4O9khr-1}}\nwenddeflinemarkup
signed char ch;
while ((ch = getopt_long(argc, argv, "", longopts, NULL)) != -1) \{
        switch (ch) \{
        case 'k':
                kind = atoi(optarg);
                break;
        case 'b':
                bits = atoi(optarg);
                break;
        case 'd':
                output_dir = optarg;
                break;
        default:
                errx(1, "Unknown option\\n");
        \}
\}
if (kind == -1) 
        errx(1, "missing required option --kind");
if (bits == -1) 
        errx(1, "missing required option --bits");
if (optind != argc - 1)
        errx(1, "missing (or extra) filenames");
char *in_filename = argv[optind];


\nwused{\\{NW12oR4B-4O9khr-1}}\nwendcode{}\nwbegindocs{9}Before starting to dwelve into the code of the threads, we must set up a bit
of global context. The number of output files (and of writter threads) if
$2^{{\Tt{}bits\nwendquote}}$. The number of mappers is the total number of processes minus
${\Tt{}n{\_}writer\nwendquote} + 1$.

\nwenddocs{}\nwbegincode{10}\sublabel{NW12oR4B-20zlE5-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-2}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwprevnextdefs{NW12oR4B-20zlE5-1}{NW12oR4B-20zlE5-3}\nwenddeflinemarkup
int rank, size;

\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegincode{11}\sublabel{NW12oR4B-3zYZcV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-3zYZcV-1}}}\moddef{Initialization~{\nwtagstyle{}\subpageref{NW12oR4B-3zYZcV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-4O9khr-1}}\nwenddeflinemarkup
MPI_Init(&argc, &argv);
MPI_Comm_size(MPI_COMM_WORLD, &size);
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
\LA{}Setup MPI datatype for preimages~{\nwtagstyle{}\subpageref{NW12oR4B-1sc054-1}}\RA{}
\LA{}Setup MPI datatype for dictionnary entries~{\nwtagstyle{}\subpageref{NW12oR4B-4cxZGD-1}}\RA{}


\nwused{\\{NW12oR4B-4O9khr-1}}\nwendcode{}\nwbegindocs{12}To easily send / receive arrays of this though \MPI, we setup a
custom \MPI datatype. Please refer to the MPI guide for details.

\nwenddocs{}\nwbegincode{13}\sublabel{NW12oR4B-1sc054-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-1sc054-1}}}\moddef{Setup MPI datatype for preimages~{\nwtagstyle{}\subpageref{NW12oR4B-1sc054-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-3zYZcV-1}}\nwenddeflinemarkup
struct preimage_t sample[2];
MPI_Datatype PreimageStruct, PreimageType;
MPI_Datatype type[2] = \{MPI_UINT64_T, MPI_UINT32_T\};
int blocklen[2] = \{1, 1\};
MPI_Aint disp[2];
MPI_Aint base, sizeofentry;

/* compute displacements of structure components */
MPI_Get_address(&sample[0].counter, &disp[0]);
MPI_Get_address(&sample[0].nonce, &disp[1]);
MPI_Get_address(sample, &base);
disp[0] -= base;
disp[1] -= base;
MPI_Type_create_struct(2, blocklen, disp, type, &PreimageStruct);
MPI_Type_commit(&PreimageStruct);

/* If compiler does padding in mysterious ways, the following may be safer */
MPI_Get_address(sample + 1, &sizeofentry);
sizeofentry -= base;
MPI_Type_create_resized(PreimageStruct, 0, sizeofentry, &PreimageType);

/* quick safety check */
int x;
MPI_Type_size(PreimageType, &x);
assert(x == sizeof(struct preimage_t));
assert(x == 12);


\nwused{\\{NW12oR4B-3zYZcV-1}}\nwendcode{}\nwbegincode{14}\sublabel{NW12oR4B-4cxZGD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-4cxZGD-1}}}\moddef{Setup MPI datatype for dictionnary entries~{\nwtagstyle{}\subpageref{NW12oR4B-4cxZGD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-3zYZcV-1}}\nwenddeflinemarkup
struct dict_t sample2[2];
MPI_Datatype type2[2] = \{MPI_UINT64_T, PreimageType\};
MPI_Datatype DictStruct, DictType;

/* compute displacements of structure components */
MPI_Get_address(&sample2[0].hash, &disp[0]);
MPI_Get_address(&sample2[0].preimage, &disp[1]);
MPI_Get_address(sample2, &base);
disp[0] -= base;
disp[1] -= base;
MPI_Type_create_struct(2, blocklen, disp, type2, &DictStruct);
MPI_Type_commit(&DictStruct);

MPI_Get_address(sample2 + 1, &sizeofentry);
sizeofentry -= base;
MPI_Type_create_resized(DictStruct, 0, sizeofentry, &DictType);


\nwused{\\{NW12oR4B-3zYZcV-1}}\nwendcode{}\nwbegindocs{15}Using \MPI, processes are numbered starting at zero. The reader is process
0. The writers are processes $1, \dots, {\Tt{}n{\_}writer\nwendquote}$. The remaining processes
are mappers. To easily distinguish between messages, we use tags.

\nwenddocs{}\nwbegincode{16}\sublabel{NW12oR4B-20zlE5-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-3}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwprevnextdefs{NW12oR4B-20zlE5-2}{NW12oR4B-20zlE5-4}\nwenddeflinemarkup
static const int READER_REQUEST_TAG = 0;
static const int NONCE_BLOCK_TAG = 1;
static const int HASH_BLOCK_TAG = 2;
static const int EOF_TAG = 3;

int n_writer, n_mapper;

\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegincode{17}\sublabel{NW12oR4B-45A6xH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-45A6xH-1}}}\moddef{Finish setup~{\nwtagstyle{}\subpageref{NW12oR4B-45A6xH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-4O9khr-1}}\nwenddeflinemarkup
n_writer = 1 << bits;
n_mapper = size - n_writer - 1;
if (rank == 0 && n_mapper <= 0)
        errx(1, "not enough MPI processes. Need %d, have %d", 2 + n_writer, size);

\nwused{\\{NW12oR4B-4O9khr-1}}\nwendcode{}\nwbegindocs{18}Nonces and hashes are processed in batches.

\nwenddocs{}\nwbegincode{19}\sublabel{NW12oR4B-20zlE5-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-4}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwprevnextdefs{NW12oR4B-20zlE5-3}{NW12oR4B-20zlE5-5}\nwenddeflinemarkup
static const int READER_BUFFER_SIZE = 65536;
\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegincode{20}\sublabel{NW12oR4B-20zlE5-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-5}}}\moddef{Global variables~{\nwtagstyle{}\subpageref{NW12oR4B-20zlE5-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-1p0Y9w-1}}\nwprevnextdefs{NW12oR4B-20zlE5-4}{\relax}\nwenddeflinemarkup
static const int WRITER_BUFFER_SIZE = 32768;

\nwused{\\{NW12oR4B-1p0Y9w-1}}\nwendcode{}\nwbegindocs{21}\nwdocspar

\section{Reading the Preimage Files}

The mapper threads will request preimage blocks from the reader. The reader
will reply with either a preimage block or an {\Tt{}EOF\nwendquote} message.

\nwenddocs{}\nwbegincode{22}\sublabel{NW12oR4B-2CLS5F-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-2CLS5F-1}}}\moddef{Reader~{\nwtagstyle{}\subpageref{NW12oR4B-2CLS5F-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-3hmYEA-1}}\nwenddeflinemarkup
printf("Reader started. %d mappers and %d writers.\\n", n_mapper, n_writer);
int preimages_read = 0;
double start = MPI_Wtime();
double wait = 0;
FILE *f = fopen(in_filename, "r");
if (f == NULL)
        err(1, "fopen on %s", in_filename);
while (1) \{
        \LA{}Read a nonce block from \code{}f\edoc{} in \code{}buffer\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-4DPF6O-1}}\RA{}
        \LA{}Wait for a request and send back \code{}buffer\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-1PkUpu-1}}\RA{}
        \LA{}Print status report~{\nwtagstyle{}\subpageref{NW12oR4B-2kelCg-1}}\RA{}
\}
fclose(f);
for (int i = 0; i < n_mapper; i++) \{
        \LA{}Wait for a request and send back \code{}EOF\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-1KncTC-1}}\RA{}
\}
printf("\\nReader finished. %d preimages read, total wait = %.1f s\\n", preimages_read, wait);


\nwused{\\{NW12oR4B-3hmYEA-1}}\nwendcode{}\nwbegindocs{23}Reading the file is straightforward. We use a buffer of {\Tt{}struct\ nonce{\_}msg{\_}t\nwendquote}.

\nwenddocs{}\nwbegincode{24}\sublabel{NW12oR4B-4DPF6O-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-4DPF6O-1}}}\moddef{Read a nonce block from \code{}f\edoc{} in \code{}buffer\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-4DPF6O-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2CLS5F-1}}\nwenddeflinemarkup
struct preimage_t buffer[READER_BUFFER_SIZE];
size_t n_items = fread(buffer, sizeof(struct preimage_t), READER_BUFFER_SIZE, f);
if (ferror(f))
        err(1, "fread in reader");
if (n_items == 0 && feof(f))
        break;

\nwused{\\{NW12oR4B-2CLS5F-1}}\nwendcode{}\nwbegindocs{25}Sending the block to the mapper is also quite simple. Because we accept
requests from anyone, we must be able to tell who asked us for a block. We
also use a specific "tag" for block requests. We use {\Tt{}MPI{\_}Bsend\nwendquote}, because it
allows us to get back to reading the file faster (at the expense of using a
bit more memory).


\nwenddocs{}\nwbegincode{26}\sublabel{NW12oR4B-1PkUpu-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-1PkUpu-1}}}\moddef{Wait for a request and send back \code{}buffer\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-1PkUpu-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2CLS5F-1}}\nwenddeflinemarkup
MPI_Status status;
double wait_start = MPI_Wtime();
MPI_Recv(NULL, 0, MPI_INT, MPI_ANY_SOURCE, READER_REQUEST_TAG, MPI_COMM_WORLD, &status);
wait += MPI_Wtime() - wait_start;
MPI_Send(buffer, n_items, PreimageType, status.MPI_SOURCE, NONCE_BLOCK_TAG, MPI_COMM_WORLD);
preimages_read += n_items;

\nwused{\\{NW12oR4B-2CLS5F-1}}\nwendcode{}\nwbegindocs{27}Once all the files have been processed, the mappers must be told to stop
sending requests. We use an empty block with the EOF tag.

\nwenddocs{}\nwbegincode{28}\sublabel{NW12oR4B-1KncTC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-1KncTC-1}}}\moddef{Wait for a request and send back \code{}EOF\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-1KncTC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2CLS5F-1}}\nwenddeflinemarkup
MPI_Status status;
MPI_Recv(NULL, 0, MPI_INT, MPI_ANY_SOURCE, READER_REQUEST_TAG, MPI_COMM_WORLD, &status);
MPI_Send(NULL, 0, MPI_INT, status.MPI_SOURCE, EOF_TAG, MPI_COMM_WORLD);


\nwused{\\{NW12oR4B-2CLS5F-1}}\nwendcode{}\nwbegindocs{29}We implement a simple form of verbosity.

\nwenddocs{}\nwbegincode{30}\sublabel{NW12oR4B-2kelCg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-2kelCg-1}}}\moddef{Print status report~{\nwtagstyle{}\subpageref{NW12oR4B-2kelCg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2CLS5F-1}}\nwenddeflinemarkup
double megabytes = preimages_read * 1.1444091796875e-05;
double rate = megabytes / (MPI_Wtime() - start);
printf("\\rNonces read: %d (%.1f Mb, %.1f Mb/s)", preimages_read, megabytes, rate);
fflush(stdout);

\nwused{\\{NW12oR4B-2CLS5F-1}}\nwendcode{}\nwbegindocs{31}\nwdocspar

\section{Hashing and Dispatching the Preimages}

Now come the mapper threads. They split input blocks into {\Tt{}n{\_}writer\nwendquote} output
buffers. When an output buffer is full, it is flushed to the corresponding
writer.

\nwenddocs{}\nwbegincode{32}\sublabel{NW12oR4B-372IYR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-372IYR-1}}}\moddef{Mapper~{\nwtagstyle{}\subpageref{NW12oR4B-372IYR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-3hmYEA-1}}\nwenddeflinemarkup
int id = rank - n_writer - 1;
\LA{}Initialize output buffers~{\nwtagstyle{}\subpageref{NW12oR4B-ary5h-1}}\RA{}
int n_processed = 0, n_invalid = 0;
while (1) \{
        \LA{}Request \code{}preimages\edoc{} from reader; if \code{}EOF\edoc{}, then \code{}break\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-1032dD-1}}\RA{}
        for (int i = 0; i < n_preimages; i++) \{
                \LA{}Compute the hash; if invalid then \code{}continue\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-3KWhDQ-1}}\RA{}
                \LA{}Push the dictionnary entry to the output buffer \code{}slot\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-2mbJc6-1}}\RA{}
                if (output_size[slot] == WRITER_BUFFER_SIZE) \{
                        \LA{}flush \code{}output[slot]\edoc{} to writer \#\code{}slot\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-2FInMm-1}}\RA{}
                \}
        \}
\}
\LA{}Flush all buffers and send \code{}EOF\edoc{} message to all writers~{\nwtagstyle{}\subpageref{NW12oR4B-1KpMsC-1}}\RA{}
printf("\\nMapper %d finished. %d dictionnary entries transmitted. %d invalid.\\n", id, n_processed, n_invalid);

\nwused{\\{NW12oR4B-3hmYEA-1}}\nwendcode{}\nwbegindocs{33}Dealing with the buffer is as simple as in the reader. So is communication with the reader.

\nwenddocs{}\nwbegincode{34}\sublabel{NW12oR4B-ary5h-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-ary5h-1}}}\moddef{Initialize output buffers~{\nwtagstyle{}\subpageref{NW12oR4B-ary5h-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-372IYR-1}}\nwenddeflinemarkup
struct dict_t output[n_writer][WRITER_BUFFER_SIZE];
int output_size[n_writer];
for (int i = 0; i < n_writer; i++)
        output_size[i] = 0;


\nwused{\\{NW12oR4B-372IYR-1}}\nwendcode{}\nwbegindocs{35}When receiving a block from the reader, we only know an upper bound on its size. We must then query its actual size from \MPI.

\nwenddocs{}\nwbegincode{36}\sublabel{NW12oR4B-1032dD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-1032dD-1}}}\moddef{Request \code{}preimages\edoc{} from reader; if \code{}EOF\edoc{}, then \code{}break\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-1032dD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-372IYR-1}}\nwenddeflinemarkup
struct preimage_t preimages[READER_BUFFER_SIZE];
MPI_Status status;
MPI_Send(NULL, 0, MPI_INT, 0, READER_REQUEST_TAG, MPI_COMM_WORLD);
MPI_Recv(preimages, READER_BUFFER_SIZE, PreimageType, 0, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
if (status.MPI_TAG == EOF_TAG)
        break;
int n_preimages;
MPI_Get_count(&status, PreimageType, &n_preimages);


\nwused{\\{NW12oR4B-372IYR-1}}\nwendcode{}\nwbegindocs{37}A priori, the nonces are valid at difficulty 33. This means that the top 33
bits of the hash must be zero.

\nwenddocs{}\nwbegincode{38}\sublabel{NW12oR4B-3KWhDQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-3KWhDQ-1}}}\moddef{Compute the hash; if invalid then \code{}continue\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-3KWhDQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-372IYR-1}}\nwenddeflinemarkup
uint32_t full_hash[8];
if (!compute_full_hash(kind, preimages + i, full_hash)) \{
        n_invalid += 1;
        continue;
\}


\nwused{\\{NW12oR4B-372IYR-1}}\nwendcode{}\nwbegindocs{39}We must extract 64 bits of the hash from {\Tt{}hash[5]\nwendquote} and {\Tt{}hash[6]\nwendquote},
excluding the most-significant bit of {\Tt{}hash[6]\nwendquote} which is always zero. We
replace it with the most-significant bit of {\Tt{}hash[4]\nwendquote}.

\nwenddocs{}\nwbegincode{40}\sublabel{NW12oR4B-2mbJc6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-2mbJc6-1}}}\moddef{Push the dictionnary entry to the output buffer \code{}slot\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-2mbJc6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-372IYR-1}}\nwenddeflinemarkup
uint64_t x = extract_partial_hash(full_hash);
int slot = bits ? (x >> (64 - bits)) : 0;
output[slot][output_size[slot]].hash = x;
output[slot][output_size[slot]].preimage.counter = preimages[i].counter;
output[slot][output_size[slot]].preimage.nonce = preimages[i].nonce;
output_size[slot] += 1;

\nwused{\\{NW12oR4B-372IYR-1}}\nwendcode{}\nwbegindocs{41}IO is easy thanks to \MPI. Recall that writer \#{\Tt{}slot\nwendquote} is actually \MPI
process ${\Tt{}slot\nwendquote} + 1$.
                
\nwenddocs{}\nwbegincode{42}\sublabel{NW12oR4B-2FInMm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-2FInMm-1}}}\moddef{flush \code{}output[slot]\edoc{} to writer \#\code{}slot\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-2FInMm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-372IYR-1}\\{NW12oR4B-1KpMsC-1}}\nwenddeflinemarkup
MPI_Send(output[slot], output_size[slot], DictType, slot + 1, HASH_BLOCK_TAG, MPI_COMM_WORLD);
n_processed += output_size[slot];
output_size[slot] = 0;


\nwused{\\{NW12oR4B-372IYR-1}\\{NW12oR4B-1KpMsC-1}}\nwendcode{}\nwbegindocs{43}When we receive the {\Tt{}EOF\nwendquote} mark from the reader, we must flush incomplete
output buffers to the writters.

\nwenddocs{}\nwbegincode{44}\sublabel{NW12oR4B-1KpMsC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-1KpMsC-1}}}\moddef{Flush all buffers and send \code{}EOF\edoc{} message to all writers~{\nwtagstyle{}\subpageref{NW12oR4B-1KpMsC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-372IYR-1}}\nwenddeflinemarkup
for (int slot = 0; slot < n_writer; slot++) \{
        \LA{}flush \code{}output[slot]\edoc{} to writer \#\code{}slot\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-2FInMm-1}}\RA{}
        MPI_Send(NULL, 0, MPI_INT, slot + 1, EOF_TAG, MPI_COMM_WORLD);
\}

\nwused{\\{NW12oR4B-372IYR-1}}\nwendcode{}\nwbegindocs{45}\nwdocspar






\section{Writing Split Dictionnaries to Disk}

It remains to describe the writers, which is almost the simplest. The writer's
{\Tt{}id\nwendquote} is its number amongst writer threads. It is its \MPI rank minus one.
Each writer writes a single split dictionnary.

\nwenddocs{}\nwbegincode{46}\sublabel{NW12oR4B-2xcEuF-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-2xcEuF-1}}}\moddef{Writer~{\nwtagstyle{}\subpageref{NW12oR4B-2xcEuF-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-3hmYEA-1}}\nwenddeflinemarkup
int id = rank - 1;
int n_eof = 0;
\LA{}Open output file \code{}f\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-QgLln-1}}\RA{}
while (n_eof < n_mapper) \{
        \LA{}Receive \code{}block\edoc{} from a mapper; if \code{}EOF\edoc{} then \code{}continue\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-DPThg-1}}\RA{}
        \LA{}Write \code{}block\edoc{} to \code{}f\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-3m2Jed-1}}\RA{}
\}
\LA{}Close \code{}f\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-RH6jl-1}}\RA{}
printf("Writer %d done (%s).\\n", id, out_filename);

\nwused{\\{NW12oR4B-3hmYEA-1}}\nwendcode{}\nwbegindocs{47}We derive the output filename from the input filename, the (optional) output
directory and the writer's {\Tt{}id\nwendquote}. The output file is opened in write mode, so
it is truncated to size zero.

\nwenddocs{}\nwbegincode{48}\sublabel{NW12oR4B-QgLln-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-QgLln-1}}}\moddef{Open output file \code{}f\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-QgLln-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2xcEuF-1}}\nwenddeflinemarkup
char out_filename[255];
char *input_base = basename(in_filename);
if (output_dir)
        sprintf(out_filename, "%s/%s.dict.%d", output_dir, input_base, id);
else
        sprintf(out_filename, "%s.dict.%d", in_filename, id);
FILE *f = fopen(out_filename, "w");
if (f == NULL)
        err(1, "[writer] Cannot open %s for writing", out_filename);

\nwused{\\{NW12oR4B-2xcEuF-1}}\nwendcode{}\nwbegindocs{49}When receiving a block from a mapper, we must distinguish between regular
and EOF messages. We must also observe the size of the hash block.

\nwenddocs{}\nwbegincode{50}\sublabel{NW12oR4B-DPThg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-DPThg-1}}}\moddef{Receive \code{}block\edoc{} from a mapper; if \code{}EOF\edoc{} then \code{}continue\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-DPThg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2xcEuF-1}}\nwenddeflinemarkup
struct dict_t block[WRITER_BUFFER_SIZE];
MPI_Status status;
MPI_Recv(block, WRITER_BUFFER_SIZE, DictType, MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status);
if (status.MPI_TAG == EOF_TAG) \{
        n_eof++;
        continue;
\}
int n_entries;
MPI_Get_count(&status, DictType, &n_entries);

\nwused{\\{NW12oR4B-2xcEuF-1}}\nwendcode{}\nwbegincode{51}\sublabel{NW12oR4B-3m2Jed-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-3m2Jed-1}}}\moddef{Write \code{}block\edoc{} to \code{}f\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-3m2Jed-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2xcEuF-1}}\nwenddeflinemarkup
size_t tmp = fwrite(block, sizeof(struct dict_t), n_entries, f);
if (tmp != (size_t) n_entries)
        err(1, "fwrite writer %d: %zd vs %d", id, tmp, n_entries);

\nwused{\\{NW12oR4B-2xcEuF-1}}\nwendcode{}\nwbegincode{52}\sublabel{NW12oR4B-RH6jl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-RH6jl-1}}}\moddef{Close \code{}f\edoc{}~{\nwtagstyle{}\subpageref{NW12oR4B-RH6jl-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-2xcEuF-1}}\nwenddeflinemarkup
if (fclose(f))
        err(1, "fclose writer %d", id);

\nwused{\\{NW12oR4B-2xcEuF-1}}\nwendcode{}\nwbegindocs{53}\nwdocspar

\section{Putting it all Toghether}

\nwenddocs{}\nwbegincode{54}\sublabel{NW12oR4B-3hmYEA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW12oR4B-3hmYEA-1}}}\moddef{Start reader, mappers and writers~{\nwtagstyle{}\subpageref{NW12oR4B-3hmYEA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW12oR4B-4O9khr-1}}\nwenddeflinemarkup
if (rank == 0) \{
        \LA{}Reader~{\nwtagstyle{}\subpageref{NW12oR4B-2CLS5F-1}}\RA{}
\} else if (rank < 1 + n_writer) \{
        \LA{}Writer~{\nwtagstyle{}\subpageref{NW12oR4B-2xcEuF-1}}\RA{}
\} else \{
        \LA{}Mapper~{\nwtagstyle{}\subpageref{NW12oR4B-372IYR-1}}\RA{}
\}

\nwused{\\{NW12oR4B-4O9khr-1}}\nwendcode{}

\nwixlogsorted{c}{{*}{NW12oR4B-1p0Y9w-1}{\nwixd{NW12oR4B-1p0Y9w-1}}}%
\nwixlogsorted{c}{{Close \code{}f\edoc{}}{NW12oR4B-RH6jl-1}{\nwixu{NW12oR4B-2xcEuF-1}\nwixd{NW12oR4B-RH6jl-1}}}%
\nwixlogsorted{c}{{Compute the hash; if invalid then \code{}continue\edoc{}}{NW12oR4B-3KWhDQ-1}{\nwixu{NW12oR4B-372IYR-1}\nwixd{NW12oR4B-3KWhDQ-1}}}%
\nwixlogsorted{c}{{Finish setup}{NW12oR4B-45A6xH-1}{\nwixu{NW12oR4B-4O9khr-1}\nwixd{NW12oR4B-45A6xH-1}}}%
\nwixlogsorted{c}{{flush \code{}output[slot]\edoc{} to writer \#\code{}slot\edoc{}}{NW12oR4B-2FInMm-1}{\nwixu{NW12oR4B-372IYR-1}\nwixd{NW12oR4B-2FInMm-1}\nwixu{NW12oR4B-1KpMsC-1}}}%
\nwixlogsorted{c}{{Flush all buffers and send \code{}EOF\edoc{} message to all writers}{NW12oR4B-1KpMsC-1}{\nwixu{NW12oR4B-372IYR-1}\nwixd{NW12oR4B-1KpMsC-1}}}%
\nwixlogsorted{c}{{Global variables}{NW12oR4B-20zlE5-1}{\nwixu{NW12oR4B-1p0Y9w-1}\nwixd{NW12oR4B-20zlE5-1}\nwixd{NW12oR4B-20zlE5-2}\nwixd{NW12oR4B-20zlE5-3}\nwixd{NW12oR4B-20zlE5-4}\nwixd{NW12oR4B-20zlE5-5}}}%
\nwixlogsorted{c}{{Header files to include}{NW12oR4B-4BXCU3-1}{\nwixu{NW12oR4B-1p0Y9w-1}\nwixd{NW12oR4B-4BXCU3-1}}}%
\nwixlogsorted{c}{{Initialization}{NW12oR4B-3zYZcV-1}{\nwixu{NW12oR4B-4O9khr-1}\nwixd{NW12oR4B-3zYZcV-1}}}%
\nwixlogsorted{c}{{Initialize output buffers}{NW12oR4B-ary5h-1}{\nwixu{NW12oR4B-372IYR-1}\nwixd{NW12oR4B-ary5h-1}}}%
\nwixlogsorted{c}{{Mapper}{NW12oR4B-372IYR-1}{\nwixd{NW12oR4B-372IYR-1}\nwixu{NW12oR4B-3hmYEA-1}}}%
\nwixlogsorted{c}{{Open output file \code{}f\edoc{}}{NW12oR4B-QgLln-1}{\nwixu{NW12oR4B-2xcEuF-1}\nwixd{NW12oR4B-QgLln-1}}}%
\nwixlogsorted{c}{{Print status report}{NW12oR4B-2kelCg-1}{\nwixu{NW12oR4B-2CLS5F-1}\nwixd{NW12oR4B-2kelCg-1}}}%
\nwixlogsorted{c}{{Process the command line}{NW12oR4B-9FeVG-1}{\nwixu{NW12oR4B-4O9khr-1}\nwixd{NW12oR4B-9FeVG-1}}}%
\nwixlogsorted{c}{{Push the dictionnary entry to the output buffer \code{}slot\edoc{}}{NW12oR4B-2mbJc6-1}{\nwixu{NW12oR4B-372IYR-1}\nwixd{NW12oR4B-2mbJc6-1}}}%
\nwixlogsorted{c}{{Read a nonce block from \code{}f\edoc{} in \code{}buffer\edoc{}}{NW12oR4B-4DPF6O-1}{\nwixu{NW12oR4B-2CLS5F-1}\nwixd{NW12oR4B-4DPF6O-1}}}%
\nwixlogsorted{c}{{Reader}{NW12oR4B-2CLS5F-1}{\nwixd{NW12oR4B-2CLS5F-1}\nwixu{NW12oR4B-3hmYEA-1}}}%
\nwixlogsorted{c}{{Receive \code{}block\edoc{} from a mapper; if \code{}EOF\edoc{} then \code{}continue\edoc{}}{NW12oR4B-DPThg-1}{\nwixu{NW12oR4B-2xcEuF-1}\nwixd{NW12oR4B-DPThg-1}}}%
\nwixlogsorted{c}{{Request \code{}preimages\edoc{} from reader; if \code{}EOF\edoc{}, then \code{}break\edoc{}}{NW12oR4B-1032dD-1}{\nwixu{NW12oR4B-372IYR-1}\nwixd{NW12oR4B-1032dD-1}}}%
\nwixlogsorted{c}{{Setup MPI datatype for dictionnary entries}{NW12oR4B-4cxZGD-1}{\nwixu{NW12oR4B-3zYZcV-1}\nwixd{NW12oR4B-4cxZGD-1}}}%
\nwixlogsorted{c}{{Setup MPI datatype for preimages}{NW12oR4B-1sc054-1}{\nwixu{NW12oR4B-3zYZcV-1}\nwixd{NW12oR4B-1sc054-1}}}%
\nwixlogsorted{c}{{Start reader, mappers and writers}{NW12oR4B-3hmYEA-1}{\nwixu{NW12oR4B-4O9khr-1}\nwixd{NW12oR4B-3hmYEA-1}}}%
\nwixlogsorted{c}{{The main program}{NW12oR4B-4O9khr-1}{\nwixu{NW12oR4B-1p0Y9w-1}\nwixd{NW12oR4B-4O9khr-1}}}%
\nwixlogsorted{c}{{Wait for a request and send back \code{}buffer\edoc{}}{NW12oR4B-1PkUpu-1}{\nwixu{NW12oR4B-2CLS5F-1}\nwixd{NW12oR4B-1PkUpu-1}}}%
\nwixlogsorted{c}{{Wait for a request and send back \code{}EOF\edoc{}}{NW12oR4B-1KncTC-1}{\nwixu{NW12oR4B-2CLS5F-1}\nwixd{NW12oR4B-1KncTC-1}}}%
\nwixlogsorted{c}{{Write \code{}block\edoc{} to \code{}f\edoc{}}{NW12oR4B-3m2Jed-1}{\nwixu{NW12oR4B-2xcEuF-1}\nwixd{NW12oR4B-3m2Jed-1}}}%
\nwixlogsorted{c}{{Writer}{NW12oR4B-2xcEuF-1}{\nwixd{NW12oR4B-2xcEuF-1}\nwixu{NW12oR4B-3hmYEA-1}}}%
\nwbegindocs{55}\nwdocspar

\end{document}
\nwenddocs{}
